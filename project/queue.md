## Redis를 활용한 대기열 구현

### 문제 상황
- 수강신청의 경우 트래픽이 특정 시간대에 집중
- 예상치 못한 수준의 트래픽에 서버가 다운될 수도 있다고 판단
- 실제로 서버에 요청하는 트래픽의 수를 제한해서 트래픽 부하를 방지할 수 있다고 판단

### 해결 방법

- Redis의 Sorted Set (ZSet)을 활용해서 대기 큐와 처리 큐를 구현했습니다.
- 처리 큐의 사이즈를 제한하고, 그 이상의 사용자에 대해선 대기 큐에 순서대로 적제합니다.
- 일정 시간마다 처리 큐의 빈 공간을 찾아 대기 큐에서 순서대로 꺼내 넣어줍니다.

```mermaid
sequenceDiagram
    participant 사용자
    participant 프론트엔드
    participant 대기열 서비스
    participant 예매 서비스
    
    사용자 ->> 프론트엔드: 티켓 예매 시작
    프론트엔드 ->> 대기열 서비스: 대기열 진입 API 호출
    대기열 서비스 -->> 프론트엔드: 토큰과 대기열 진입 확인

    loop 웨이팅 중인 동안
        프론트엔드 ->> 대기열 서비스: 웨이팅 수 반환 요청 API 호출 (토큰 포함)
        대기열 서비스 -->> 프론트엔드: 상태, 대기 수, 남은 시간 반환
        
        alt 바로 티켓 예매 가능
            프론트엔드 ->> 예매 서비스: 티켓 예매 API 호출
            예매 서비스 -->> 프론트엔드: 티켓 예매 결과 반환
        else 웨이팅 중
            alt 웨이팅 탈출 요청
                프론트엔드 ->> 대기열 서비스: 웨이팅 큐 탈출 API 호출
                대기열 서비스 -->> 프론트엔드: 웨이팅 큐 탈출 확인
            end
        end
        대기열 서비스 ->> 대기열 서비스: 큐 상태 업데이트 (스케줄러)
    end
```

### 결과
- 실제 서비스에 요청을 하는 사용자를 1000명을 제한
- 집중적으로 몰리는 트래픽을 보다 안정적으로 처리가능해졌습니다.